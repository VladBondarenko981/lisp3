<p align="center"><b>МОНУ НТУУ КПІ ім. Ігоря Сікорського ФПМ СПіСКС</b></p>
<p align="center">
<b>Звіт з лабораторної роботи 3</b><br/>
"Функціональний і імперативний підходи до роботи зі списками"<br/>
</p>
<p align="right">Студент: Бондаренко Владислав Олексийович КВ-13<p>
<p align="right">Рік: 2024<p>

## Загальне завдання

  Реалізуйте алгоритм сортування чисел у списку двома способами: функціонально і імперативно. 

  1. Функціональний варіант реалізації має базуватись на використанні рекурсії і конструюванні нових списків щоразу, коли необхідно виконати зміну вхідного списку. Не допускається використання: деструктивних операцій, циклів, функцій вищого порядку або функцій для роботи зі списками/послідовностями, що використовуються як функції вищого порядку. Також реалізована функція не має бути функціоналом (тобто приймати на вхід функції в якості аргументів). 

  2. Імперативний варіант реалізації має базуватись на використанні циклів і деструктивних функцій (псевдофункцій). Не допускається використання функцій вищого порядку або функцій для роботи зі списками/послідовностями, що використовуються як функції вищого порядку. Тим не менш, оригінальний список цей варіант реалізації також не має змінювати, тому перед виконанням деструктивних змін варто застосувати функцію  copy-list	 (в разі необхідності). Також реалізована функція не має бути функціоналом (тобто приймати на вхід функції в якості аргументів).

  Алгоритм, який необхідно реалізувати, задається варіантом (п. 3.1.1). Зміст і шаблон звіту наведені в п. 3.2. 
    
  Кожна реалізована функція має бути протестована для різних тестових наборів. Тести мають бути оформленні у вигляді модульних тестів (наприклад, як наведено в п. 2.3). 


## Варіант 2

  Алгоритм сортування обміном №1 (без оптимізацій) за незменшенням.
  
#Завдання 1
```lisp
(defun swap-adjacent (list)
  "Обміняйте сусідні елементи в ЛІСТі."
  (cond
    ((null (cdr list)) list)                       ; Якщо список порожній або містить лише один елемент, поверніть його.
    ((> (car list) (cadr list))                    ; Якщо перший елемент більше за другий, обміняйте їх.
     (cons (cadr list) (swap-adjacent (cons (car list) (cddr list)))))
    (t
     (cons (car list) (swap-adjacent (cdr list))))))  ; Інакше, продовжуйте обмінюватися з рештою списку.
(defun bubble-sort-functional (list)
  "Сортуйте ЛІСТ за допомогою функціонального підходу з методом бульбашки."
  (let ((swapped-list (swap-adjacent list)))      ; Застосувати обмін сусідніх елементів.
    (if (equal swapped-list list)                  ; Якщо більше обмінів не потрібні, поверніть відсортований список.
        list
      (bubble-sort-functional swapped-list))))    ; Інакше, рекурсивно відсортуйте змінений список.

(defun run-bubble-sort-functional-tests ()
  "Запустіть тестові випадки для bubble-sort-functional."
  (format t "Тест 1: bubble-sort-functional ~%")
  (format t "~a~%" (equal (bubble-sort-functional '(4 2 5 1 3)) '(1 2 3 4 5)))
  (format t "Тест 2: bubble-sort-functional ~%")
  (format t "~a~%" (equal (bubble-sort-functional '(1 2 3 4 5)) '(1 2 3 4 5)))
  (format t "Тест 3: bubble-sort-functional (порожній список) ~%")
  (format t "~a~%" (equal (bubble-sort-functional '()) '())))

(run-bubble-sort-functional-tests)
```


##Завдання 2
```lisp

(defun bubble-sort-imperative (lst)
  "Сортуйте ЛСТ за стандартним імперативним методом бульбашки."
  (let ((sorted-list (copy-list lst)))            ; Скопіюйте список для сортування.
    (dotimes (i (1- (length sorted-list)))       ; Зовнішній цикл над списком.
      (dotimes (j (- (length sorted-list) i 1)) ; Внутрішній цикл для порівнянь.
        (let ((current (nth j sorted-list))
              (next (nth (1+ j) sorted-list)))
          (when (> current next)                 ; Якщо поточний елемент більше наступного, обміняйте їх.
            (setf (nth j sorted-list) next)
            (setf (nth (1+ j) sorted-list) current)))))
  sorted-list)

(defun run-bubble-sort-imperative-tests ()
  "Запустіть тестові випадки для bubble-sort-imperative."
  (format t "Тест 1: bubble-sort-imperative ~%")
  (format t "~a~%" (equal (bubble-sort-imperative '(4 2 5 1 3)) '(1 2 3 4 5)))
  (format t "Тест 2: bubble-sort-imperative ~%")
  (format t "~a~%" (equal (bubble-sort-imperative '(1 2 3 4 5)) '(1 2 3 4 5)))
  (format t "Тест 3: bubble-sort-imperative (порожній список) ~%")
  (format t "~a~%" (equal (bubble-sort-imperative '()) '())))

(run-bubble-sort-imperative-tests)
```
